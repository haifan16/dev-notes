（目前记得有点乱，待整理）

分代垃圾回收：

在新生代建立一个全局的数据结构 Remembered Set (记忆集)，用于记录新生代和老年代之间存在跨代引用的关系，避免 Minor GC 时需要对老年代全扫描一遍带来的低效

分区垃圾回收：

每个 Region 都需要维护一个 Remembered Set，用于记录新生代和老年代之间发生了跨代引用的老年代的内存，避免 Minor GC 时需要对老年代全扫描一遍带来的低效
-> 内存占用更大

Remembered Set 是一种抽象的数据结构，记录了发生跨代引用之间的关系。而从新生代确认到对应的老年代的粒度，可以存在“卡精度”，具体就是可以定位到老年代中哪一块内存区域，也就是被称为卡表技术（Card Table）（采用卡表的方式实现了记忆集）

1. 卡表技术是为了解决在 Young Generation 垃圾回收时，还需遍历整个 Old Generation 导致的效率低下问题，因为使用卡表技术后扫描 Young Generation 只需扫描 Young Generation 和那些脏卡，不需要遍历整个 Old Generation，效率较高
2. 而卡表状态的维护，比如何时更新等都是通过**写屏障**技术来完成的

（图）

在初次标识时要去找根对象，有些根对象是存活在 Old Generation 的，如果去遍历 Old Generation 查找这个根对象，效率会比较低
-> 因此采用卡表技术，将 Old Generation 的区域细分成很多个 card。如果当前某个 card 引用了 Young Generation 中的某个对象，则这个 card 被称为脏 card
-> 这样就缩小了搜索范围，只需关注脏 card 就好，提高了扫描根对象的效率

被引用的新生代的区域会有一个 Remembered Set，会记录外部对我的一些引用，即记录有哪些脏 card，将来对新生代做垃圾回收时，就可以根据新生代知道它对应了哪些脏 card

在引用变更的时候都更新脏 card，是一个异步操作，不会立即更新，会将脏卡的指令放入一个 dirty card 队列中，将来由一个线程完成脏 card 的更新操作