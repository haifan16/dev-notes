## JDK 1.8 分代模型

（图）

（图）

## 常见的垃圾回收器

### 串行垃圾回收器：Serial & Serial Old
   
单线程的工作方式（会暂停所有用户线程）

（图）

注意演变的变化====

### 并行的垃圾回收器（高吞吐量）：Parallel Scavenge & Parallel Old

JDK 8 默认的垃圾回收器

（图）

**以上四种垃圾回收器 Serial、Serial Old、PS、PO 都会导致一个现象：用户线程的阻塞**

用户线程暂停 = STW

垃圾回收时，用户在访问时会直接卡住（没有线程给用户程序用）

### 并发的垃圾回收器（高响应速度）：ParNew & CMS

ParNew 是 Young Generatoin，CMS 是 Old Generation

（图）

### CMS

其他的 Old Generation 垃圾回收器 Serial Old、PO 都采取**标记整理**，但是 CMS 采取**标记清除**

（图）

(1) **初始标记**：找到所有 GC Roots，短暂 STW，简单标记一下
(2) **并发标记**：
    - 根据 GC Roots 进行对象图的遍历，且该阶段不会暂停用户线程，允许 GC 和用户线程并发执行
    - 通过写屏障技术记录下发生错标问题的黑色对象，并放入队列中
(3) **重新标记**：会通过“增量更新”的解决方案解决上一阶段产生的错标问题
(4) **并发清理**：清理掉确定会被回收的垃圾

浮动垃圾：在 GC 线程与用户线程并发进行的阶段，GC 线程在“并发标记”阶段，在搜集垃圾，但是在此阶段用户线程的操作导致了原先被“初始标记”的“非垃圾对象”变为了“垃圾对象”，而此时 GC 无法检测到，则该垃圾对象被称为“浮动垃圾”

错标：被“初始标记”的垃圾对象，在“并发标记”阶段因为用户线程的影响变为了“非垃圾对象”

注意：
(1) “浮动垃圾”无所谓，在下次垃圾回收时会把该垃圾回收，不会有什么特别的影响；但是“错标”的线程，会导致要使用的对象被回收，就会造成影响
-> 所以接下来的“重新标记”阶段就是要解决“错标”的问题
(2) “初始标记”和“重新标记”都会产生极其短暂的 STW，但是可以忽略不计
(3) **当 CMS 并发处理失败时，会立即切换 Serial Old 来处理**
(4) CMS 解决错标问题采用了“增量更新”的方式。对于那些黑色增加对白色的引用，会通过写屏障技术记录下来，在重新标记阶段以黑色为根重新扫描一遍，从而解决错标的问题

不好的地方：
(1) 内存碎片
(2) 浮动垃圾
(3) 如果 CMS 运行期间预留的空间不足以让用户线程分配一个对象，则并发失败。并发失败时会先冻结用户线程，然后启动 Serial Old 来回收 Old Generation

总结：
(1) CMS 解决了什么问题？
-> 解决了 STW 时间过长的问题，使垃圾回收时用户的等待时间变短
(2) JDK 1.8 之前都是分代垃圾回收，所以就只有分代垃圾回收器；JDK 1.8 之后 都是分区垃圾回收，所以 G1、ZGC 等就没有 Old Generation、Young Generation 的概念了

补充：
1. 吞吐量 = 运行用户代码的时间 / (运行用户代码的时间 + 运行垃圾回收的时间）
   分母就是处理器总共耗费的时间
2. 是否需要发生 STW 的一个重要依据是什么？
-> 是否需要移动对象
3. 标记清除和标记整理最大的本质区别是什么？
-> 前面的标记动作都一样；标记整理算法需要所有存活的对象移动挨到一起，而标记清除算法直接删除，所以会有内存碎片。
4. 为什么 CMS 要采用标记清除？而不是标记整理？
-> 因为标记整理算法涉及到对象的移动，在对象移动阶段必须 STW，而 CMS 的第四阶段是并发清理阶段，是不会 STW 的，因为要允许用户线程并发执行

#### CMS 并发失败的问题

在第四阶段（并发清理阶段），CMS 不会 STW，依然是 GC 线程和用户线程一起运行，并不能像其他 Old Generation 垃圾回收器一样那样等垃圾快满了再回收，而是在并发清理阶段预留一定的空间给程序运行。当无法为程序分配足够的空间时，则并发失败，冻结用户线程，然后换为 Serial Old 来清理

其他垃圾回收器：GC 线程垃圾回收之后用户线程再使用；
CMS：在并发清理阶段（回收阶段）也会让用户线程继续运行 -> 所以 CMS 需要在垃圾回收阶段预留足够的空间供用户线程使用，一旦发现用户线程要使用的空间大于预留的空间，则并发失败

#### CMS 最严重的两个问题 & 优化

1. 标记清除造成的内存碎片问题

不会进行内存压缩
-> 回收后会留下大量不连续的内存碎片
-> 以下场景会导致严重问题：当 Young Generation 发生 Minor GC 时，如果 Survivor 区容纳不下幸存对象，这些对象会尝试晋升至老年代。如果老年代碎片过多 -> 没有足够的连续空间来容纳大对象

解决：让 CMS 执行一定次数的 Full GC 后，周期性地触发一次标记整理，控制住内存碎片的数量。配置参数：
```
-XX:+UseCMSCompactAtFullCollection
-XX:CMSFullGCsBeforeCompaction=5
```

2. 并发失败导致回退到 Serial Old GC

JVM 会退回到单线程、阻塞式的 Serial Old GC -> 导致长时间的 STW

解决：降低触发 CMS GC 的阈值，让其能够预留足够的空间

```
-XX:CMSInitiatingOccupancyFraction=70
-XX:+UseCMSInitiatingOccupancyOnly
```